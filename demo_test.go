package paillier

import (
	"bufio"
	"bytes"
	"context"
	"fmt"
	"io"
	"io/ioutil"
	"math/big"
	"net/http"
	"os"
	"strconv"
	"strings"
	"testing"
	"time"

	"github.com/netcloth/go-sdk/client"
	"github.com/netcloth/go-sdk/util"

	"github.com/netcloth/netcloth-chain/hexutil"
	vmtypes "github.com/netcloth/netcloth-chain/modules/vm/types"
	sdk "github.com/netcloth/netcloth-chain/types"

	"github.com/stretchr/testify/require"
)

const (
	abiFilePath = "/Users/zhuliting/go/paillier-1/contract/paillier.abi"
	yamlPath    = "/Users/zhuliting/go/paillier-1/config/sdk.yaml"

	contractBech32Addr = "nch1hmljmh2n4esr6de8fd9jjnsth3ty0ux7d7082m"
)

var (
	amount = sdk.NewCoin(sdk.DefaultBondDenom, sdk.NewInt(0))
)

func TestPaillierDemo(t *testing.T) {
	// 1. generate pk and sk
	pk, sk := getRSAKeyPair()
	//pk, _ := getRSAKeyPair()

	SetN2(t, pk.N2)

	// 2. read data from file
	lines := readDataFromFile("data.txt")

	for idx, items := range lines {
		fmt.Println(fmt.Sprintf("===================== 第 %d 组测试数据 =====================", idx))
		// generate taskId
		taskId := fmt.Sprintf("00000000000000000000000000000000000000000000000000000000000000%02d", idx)
		fmt.Println(fmt.Sprintf("task id: %s", taskId))

		clear(t, taskId)

		// 3. call contract to do paillier add
		for i, item := range items {
			//fmt.Println(fmt.Sprintf("%d", item))
			cipherText, _ := pk.Encrypt(item)
			fmt.Println(fmt.Sprintf("机构 %d, 明文贷款额：%d --> 加密密文：%d", i, item, cipherText))
			paillerAdd(t, taskId, cipherText)

			break
		}

		// 4. query result from contract
		result := QueyrPaillierResult(taskId)
		fmt.Println(fmt.Sprintf("===================== 第 %d 组测试结果 =====================", idx))
		fmt.Println(fmt.Sprintf("合约计算出的结果: %v", result))

		// 5. decrypt result
		// Test the homomorphic property
		sum, err := sk.Decrypt(result)
		if err != nil {
			t.Errorf("decrypt failed: %v", err.Error())
			return
		}

		fmt.Println(fmt.Sprintf("使用RSA私钥解密后的结果: [%d]", sum))
		fmt.Println(fmt.Sprintf("=========================================================="))

		break
		time.Sleep(2)
	}
}

func TestPaillierLocal(t *testing.T) {
	pk, sk, _ := GenerateKeyPair(32)

	N, g := pk.ToDecimalString()
	fmt.Println(fmt.Sprintf("RSA公钥：\nn: %s\ng: %s", N, g))
	fmt.Println(fmt.Sprintf("RSA N2: %s", pk.N2.Text(10)))

	mu, lam := sk.ToDecimalString()
	fmt.Println(fmt.Sprintf("RSA私钥：\nλ: %s\nμ: %s", lam, mu))

	//var inputs = [...]int64{6311, 6890, 663, 4242, 8376, 7961, 6634, 4969, 7808, 5866, 9558, 3578, 8268, 2281, 4617, 2289, 1553, 4104, 8725, 9861, 2407, 5081, 1618, 1208, 5409, 7735, 9171, 1649, 5796, 7113}
	var inputs = [...]int64{11, 89}

	fmt.Println(fmt.Sprintf("明文的贷款数额：\n%d", inputs))

	var encryptInputs []*big.Int
	for _, value := range inputs {
		cipherText, _ := pk.Encrypt(value)
		encryptInputs = append(encryptInputs, cipherText)
	}
	fmt.Println(fmt.Sprintf("RSA加密后的贷款数额：\n%d", encryptInputs))

	encryptSum := pk.BatchAdd(encryptInputs...)
	fmt.Println(fmt.Sprintf("累加后的加密贷款总额：\n%d", encryptSum))

	// Test the homomorphic property
	sum, err := sk.Decrypt(encryptSum)
	if err != nil {
		t.Errorf("PublicKey.BatchAdd() error = invalid ciphertext generated by addition")
		return
	}

	fmt.Println(fmt.Sprintf("RSA解密后的贷款总额:\n%d", sum))
}

func readDataFromFile(filePath string) (results [][]int64) {
	file, err := os.Open(filePath)
	if err != nil {
		panic(err)
	}
	defer file.Close()

	buf := bufio.NewReader(file)

	for {
		// read data by line
		line, err := buf.ReadString('\n')
		line = strings.TrimSpace(line)
		//fmt.Println(fmt.Sprintf("new line: %s", line))

		// trim '[' / ']'
		line = strings.Trim(line, "[")
		line = strings.Trim(line, "]")

		stringSlice := strings.Split(line, ",")
		var result []int64
		for _, s := range stringSlice {
			s = strings.TrimSpace(s)

			i64, err := strconv.ParseInt(s, 10, 64)
			if err != nil {
				panic(err)
			}
			result = append(result, i64)
		}
		results = append(results, result)

		if err != nil && err == io.EOF {
			break
		}

	}
	return results
}

func clear(t *testing.T, taskId string) {
	const (
		funcName = "clear"
	)

	var R [32]byte
	taskIdBin, err := hexutil.Decode(taskId)
	copy(R[:], taskIdBin)

	payload, err := util.BuildPayloadByABIFile(abiFilePath, funcName, R)
	//t.Log(fmt.Sprintf("%x", payload))
	require.NoError(t, err)

	client, err := client.NewNCHClient(yamlPath)
	res, err := client.ContractCall(contractBech32Addr, payload, amount, true)
	if err != nil {
		t.Fatal(err)
	} else {
		t.Log("调用合约响应结果：", util.ToJsonIgnoreErr(res))
	}
}

func SetN2(t *testing.T, n2 *big.Int) {
	const (
		funcName = "setN2"
	)

	client, err := client.NewNCHClient(yamlPath)

	payload, err := util.BuildPayloadByABIFile(abiFilePath, funcName, n2)
	t.Log(fmt.Sprintf("%x", payload))
	require.NoError(t, err)

	res, err := client.ContractCall(contractBech32Addr, payload, amount, true)
	if err != nil {
		t.Fatal(err)
	} else {
		t.Log(util.ToJsonIgnoreErr(res))
	}
}

func paillerAdd(t *testing.T, taskId string, value *big.Int) {
	const (
		funcName = "paillierAdd"
	)

	var R [32]byte
	taskIdBin, err := hexutil.Decode(taskId)
	copy(R[:], taskIdBin)

	payload, err := util.BuildPayloadByABIFile(abiFilePath, funcName, R, value)
	//t.Log(fmt.Sprintf("%x", payload))
	require.NoError(t, err)

	client, err := client.NewNCHClient(yamlPath)
	res, err := client.ContractCall(contractBech32Addr, payload, amount, true)
	if err != nil {
		t.Fatal(err)
	} else {
		msg := "成功"
		if res.BroadcastResult.Code != uint32(0) {
			msg = "失败"
		}
		//t.Log(fmt.Sprintf("调用合约响应结果: %s, txHash: %s", msg, res.CommitResult.Hash.String()))
		fmt.Println(fmt.Sprintf("\t\t调用合约: %s, 交易哈希: %s， 区块高度: %d", msg, res.CommitResult.Hash.String(), res.CommitResult.Height))

	}
}

func getRSAKeyPair() (*PublicKey, *PrivateKey) {
	pk, sk, _ := GenerateKeyPair(32)

	N, g := pk.ToDecimalString()
	fmt.Println(fmt.Sprintf("RSA公钥：n: %s g: %s", N, g))
	fmt.Println(fmt.Sprintf("RSA N2: %s", pk.N2.Text(10)))

	mu, lam := sk.ToDecimalString()
	fmt.Println(fmt.Sprintf("RSA私钥：λ: %s μ: %s", lam, mu))

	return pk, sk
}

func QueyrPaillierResult(taskId string) (result *big.Int) {
	const (
		funcName = "queryResult"
	)

	type QueryResult struct {
		Gas    int64
		Result []*big.Int
	}

	var R [32]byte
	taskIdBin, _ := hexutil.Decode(taskId)
	copy(R[:], taskIdBin)

	payload, _ := util.BuildPayloadByABIFile(abiFilePath, funcName, R)
	addr, _ := sdk.AccAddressFromBech32(contractBech32Addr)
	msg := vmtypes.NewMsgContract(addr, addr, payload, amount)
	fmt.Println(fmt.Sprintf("QueyrPaillierResult msg: %v", util.ToJsonIgnoreErr(msg)))

	buffer := bytes.NewBuffer(msg.GetSignBytes())
	request, err := http.NewRequest("POST", "http://localhost:1317/vm/estimate_gas", buffer)
	if err != nil {
		fmt.Println("http request error")
	}
	client := http.Client()
	resp, err := client.Do(request.WithContext(context.TODO()))
	if err != nil {
		fmt.Println("client Do error")
	}
	respBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Println("ioutil readall error")
	}
	/*
		if err != nil {
			fmt.Println(fmt.Sprintf("Execute Command failed: %v", err))
			return
		}
		// result example: {"Gas":8516,"Result":[0]}
		//fmt.Println(fmt.Sprintf("%s", string(output)))

		var res QueryResult
		err = json.Unmarshal(output, &res)
		if err != nil {
			fmt.Println(fmt.Sprintf("unmarshal result failed: %v", err))
			return
		}

		result = res.Result[0]
		//fmt.Println(fmt.Sprintf("result: %d", result))


	*/
	return result
}
