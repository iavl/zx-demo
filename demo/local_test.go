package demo

import (
	"fmt"
	"math/big"
	"testing"

	"github.com/iavl/zx-demo/paillier"
)

func TestPaillierLocal(t *testing.T) {
	pk, sk, _ := paillier.GenerateKeyPair(32)

	N, g := pk.ToDecimalString()
	fmt.Println(fmt.Sprintf("RSA公钥：\nn: %s\ng: %s", N, g))
	fmt.Println(fmt.Sprintf("RSA N2: %s", pk.N2.Text(10)))

	mu, lam := sk.ToDecimalString()
	fmt.Println(fmt.Sprintf("RSA私钥：\nλ: %s\nμ: %s", lam, mu))

	var inputs = [...]int64{6311, 6890, 663, 4242, 8376, 7961, 6634, 4969, 7808, 5866, 9558, 3578, 8268, 2281, 4617, 2289, 1553, 4104, 8725, 9861, 2407, 5081, 1618, 1208, 5409, 7735, 9171, 1649, 5796, 7113}
	//var inputs = [...]int64{11, 89}

	fmt.Println(fmt.Sprintf("明文的贷款数额：\n%d", inputs))

	var encryptInputs []*big.Int
	for _, value := range inputs {
		cipherText, _ := pk.Encrypt(value)
		encryptInputs = append(encryptInputs, cipherText)
	}
	fmt.Println(fmt.Sprintf("RSA加密后的贷款数额：\n%d", encryptInputs))

	encryptSum := pk.BatchAdd(encryptInputs...)
	fmt.Println(fmt.Sprintf("累加后的加密贷款总额：\n%d", encryptSum))

	// Test the homomorphic property
	sum, err := sk.Decrypt(encryptSum)
	if err != nil {
		t.Errorf("PublicKey.BatchAdd() error = invalid ciphertext generated by addition")
		return
	}

	fmt.Println(fmt.Sprintf("RSA解密后的贷款总额:\n%d", sum))
}
