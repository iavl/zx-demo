package main

import (
	"bufio"
	"fmt"
	"io"
	"math/big"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/iavl/zx-demo/paillier"

	"github.com/iavl/zx-demo/utils"
)

func PaillierDemo() {
	// 1. generate pk and sk
	pk, sk := utils.GetRSAKeyPair()

	// 2. read data from file
	lines := readDataFromFile("./demo/data.txt")
	for idx, items := range lines {

		// generate taskId
		taskId := fmt.Sprintf("0000000000000000000000000000000000000000000000000000000000000%03d", idx)
		utils.PaillerMain(pk, sk, items, taskId)
		break
		time.Sleep(2)
	}
}

func readDataFromFile(filePath string) (results [][]int64) {
	file, err := os.Open(filePath)
	if err != nil {
		panic(err)
	}
	defer file.Close()

	buf := bufio.NewReader(file)

	for {
		// read data by line
		line, err := buf.ReadString('\n')
		line = strings.TrimSpace(line)
		//fmt.Println(fmt.Sprintf("new line: %s", line))

		// trim '[' / ']'
		line = strings.Trim(line, "[")
		line = strings.Trim(line, "]")

		stringSlice := strings.Split(line, ",")
		var result []int64
		for _, s := range stringSlice {
			s = strings.TrimSpace(s)

			i64, err := strconv.ParseInt(s, 10, 64)
			if err != nil {
				panic(err)
			}
			result = append(result, i64)
		}
		results = append(results, result)

		if err != nil && err == io.EOF {
			break
		}

	}
	return results
}

func PaillierLocal() {
	pk, sk, _ := paillier.GenerateKeyPair(32)

	N, g := pk.ToDecimalString()
	fmt.Println(fmt.Sprintf("RSA公钥：\nn: %s\ng: %s", N, g))
	fmt.Println(fmt.Sprintf("RSA N2: %s", pk.N2.Text(10)))

	mu, lam := sk.ToDecimalString()
	fmt.Println(fmt.Sprintf("RSA私钥：\nλ: %s\nμ: %s", lam, mu))

	var inputs = [...]int64{6311, 6890, 663, 4242, 8376, 7961, 6634, 4969, 7808, 5866, 9558, 3578, 8268, 2281, 4617, 2289, 1553, 4104, 8725, 9861, 2407, 5081, 1618, 1208, 5409, 7735, 9171, 1649, 5796, 7113}
	//var inputs = [...]int64{11, 89}

	fmt.Println(fmt.Sprintf("明文的贷款数额：\n%d", inputs))

	var encryptInputs []*big.Int
	for _, value := range inputs {
		cipherText, _ := pk.Encrypt(value)
		encryptInputs = append(encryptInputs, cipherText)
	}
	fmt.Println(fmt.Sprintf("RSA加密后的贷款数额：\n%d", encryptInputs))

	encryptSum := pk.BatchAdd(encryptInputs...)
	fmt.Println(fmt.Sprintf("累加后的加密贷款总额：\n%d", encryptSum))

	// Test the homomorphic property
	sum, err := sk.Decrypt(encryptSum)
	if err != nil {
		fmt.Println("PublicKey.BatchAdd() error = invalid ciphertext generated by addition")
		return
	}

	fmt.Println(fmt.Sprintf("RSA解密后的贷款总额:\n%d", sum))
}

func main() {
	PaillierDemo()
}
