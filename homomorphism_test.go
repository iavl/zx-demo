package paillier

import (
	"fmt"
	"math/big"
	"testing"
)

func TestPublicKey_Add(t *testing.T) {
	pk, sk, err := GenerateKeyPair(1024)
	if err != nil {
		t.Errorf("Error generating key pair")
		return
	}
	ct2, _ := pk.Encrypt(2)
	ct245, _ := pk.Encrypt(245)

	type args struct {
		ct1 *big.Int
		ct2 *big.Int
	}

	tests := []struct {
		name    string
		args    args
		want    int64
		wantErr bool
	}{
		{
			"invalid inputs, must return error",
			args{zero, zero},
			0,
			true,
		},
		{
			"valid inputs, must return a valid ciphertext",
			args{ct2, ct245},
			247,
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := pk.Add(tt.args.ct1, tt.args.ct2)
			if (err != nil) != tt.wantErr {
				t.Errorf("PublicKey.Add() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if err != nil {
				return
			}

			// Test the homomorphic property
			sum, err := sk.Decrypt(got)
			if err != nil {
				t.Errorf("PublicKey.Add() error = invalid ciphertext generated by addition")
				return
			}
			if sum != tt.want {
				t.Errorf("PublicKey.Add() = %v, want %v", sum, tt.want)
			}
		})
	}
}

func TestPublicKey_MultPlaintext(t *testing.T) {
	pk, sk, _ := GenerateKeyPair(1024)

	ct2, _ := pk.Encrypt(2)
	ct36, _ := pk.Encrypt(36)

	type args struct {
		ct *big.Int
		pt int64
	}

	tests := []struct {
		name    string
		args    args
		want    int64
		wantErr bool
	}{
		{
			"invalid inputs, must return error",
			args{zero, 0},
			0,
			true,
		},
		{
			"valid inputs, must return a valid ciphertext",
			args{ct2, 2},
			4,
			false,
		},
		{
			"valid inputs, must return a valid ciphertext",
			args{ct36, 36},
			1296,
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := pk.MultPlaintext(tt.args.ct, tt.args.pt)
			if (err != nil) != tt.wantErr {
				t.Errorf("PublicKey.MultPlaintext() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if err != nil {
				return
			}

			// Test the homomorphic property
			sum, err := sk.Decrypt(got)
			if err != nil {
				t.Errorf("PublicKey.MultPlaintext() error = invalid ciphertext generated by addition")
				return
			}
			if sum != tt.want {
				t.Errorf("PublicKey.MultPlaintext() = %v, want %v", sum, tt.want)
			}
		})
	}
}

func TestPublicKey_AddPlaintext(t *testing.T) {
	pk, sk, _ := GenerateKeyPair(1024)

	ct2, _ := pk.Encrypt(2)
	ct36, _ := pk.Encrypt(36)

	type args struct {
		ct *big.Int
		pt int64
	}

	tests := []struct {
		name    string
		args    args
		want    int64
		wantErr bool
	}{
		{
			"invalid inputs, must return error",
			args{zero, 0},
			0,
			true,
		},
		{
			"valid inputs, must return a valid ciphertext",
			args{ct2, 272},
			274,
			false,
		},
		{
			"valid inputs, must return a valid ciphertext",
			args{ct36, 36},
			72,
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := pk.AddPlaintext(tt.args.ct, tt.args.pt)
			if (err != nil) != tt.wantErr {
				t.Errorf("PublicKey.AddPlaintext() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if err != nil {
				return
			}

			// Test the homomorphic property
			sum, err := sk.Decrypt(got)
			if err != nil {
				t.Errorf("PublicKey.AddPlaintext() error = invalid ciphertext generated by addition")
				return
			}
			if sum != tt.want {
				t.Errorf("PublicKey.AddPlaintext() = %v, want %v", sum, tt.want)
			}
		})
	}
}

func TestInput(t *testing.T) {
	var inputs = [...]int64{6311, 6890, 663, 4242, 8376, 7961, 6634, 4969, 7808, 5866, 9558, 3578, 8268, 2281, 4617, 2289, 1553, 4104, 8725, 9861, 2407, 5081, 1618, 1208, 5409, 7735, 9171, 1649, 5796, 7113}
	var sum int64 = 0
	for _, value := range inputs {
		sum += value
	}
	fmt.Println(fmt.Sprintf("sum :%d", sum))
}

func TestBatchAdd(t *testing.T) {
	pk, sk, _ := GenerateKeyPair(32)

	N, g := pk.ToDecimalString()
	fmt.Println(fmt.Sprintf("RSA公钥：\nn: %s\ng: %s", N, g))
	fmt.Println(fmt.Sprintf("RSA N2: %s", pk.N2.Text(10)))

	mu, lam := sk.ToDecimalString()
	fmt.Println(fmt.Sprintf("RSA私钥：\nλ: %s\nμ: %s", lam, mu))

	//var inputs = [...]int64{6311, 6890, 663, 4242, 8376, 7961, 6634, 4969, 7808, 5866, 9558, 3578, 8268, 2281, 4617, 2289, 1553, 4104, 8725, 9861, 2407, 5081, 1618, 1208, 5409, 7735, 9171, 1649, 5796, 7113}
	var inputs = [...]int64{11, 89}

	fmt.Println(fmt.Sprintf("明文的贷款数额：\n%d", inputs))

	var encryptInputs []*big.Int
	for _, value := range inputs {
		cipherText, _ := pk.Encrypt(value)
		encryptInputs = append(encryptInputs, cipherText)
	}
	fmt.Println(fmt.Sprintf("RSA加密后的贷款数额：\n%d", encryptInputs))

	encryptSum := pk.BatchAdd(encryptInputs...)
	fmt.Println(fmt.Sprintf("累加后的加密贷款总额：\n%d", encryptSum))

	// Test the homomorphic property
	sum, err := sk.Decrypt(encryptSum)
	if err != nil {
		t.Errorf("PublicKey.BatchAdd() error = invalid ciphertext generated by addition")
		return
	}

	fmt.Println(fmt.Sprintf("RSA解密后的贷款总额:\n%d", sum))
}

func TestPublicKey_Sub(t *testing.T) {
	pk, sk, _ := GenerateKeyPair(1024)

	c2, _ := pk.Encrypt(2)
	c3, _ := pk.Encrypt(3)
	c4, _ := pk.Encrypt(4)
	c5, _ := pk.Encrypt(5)
	c23578, _ := pk.Encrypt(23578)
	c115, _ := pk.Encrypt(115)

	tests := []struct {
		name string
		ct1  *big.Int
		ct2  *big.Int
		want int64
	}{
		{"3-2", c3, c2, 3 - 2},
		{"5-2", c5, c2, 5 - 2},
		{"5-3", c5, c3, 5 - 3},
		{"5-4", c5, c4, 5 - 4},
		{"5-4", c23578, c115, 23578 - 115},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := pk.Sub(tt.ct1, tt.ct2)

			// Test the homomorphic property
			sum, err := sk.Decrypt(got)
			if err != nil {
				t.Errorf("PublicKey.Sub() error = invalid ciphertext generated by addition")
				return
			}
			if sum != tt.want {
				t.Errorf("PublicKey.Sub() = %v, want %v", sum, tt.want)
			}
		})
	}
}

func TestPublicKey_DivPlaintext(t *testing.T) {
	pk, sk, _ := GenerateKeyPair(1024)

	ct2, _ := pk.Encrypt(2)
	ct36, _ := pk.Encrypt(36)

	type args struct {
		ct *big.Int
		pt int64
	}

	tests := []struct {
		name    string
		args    args
		want    int64
		wantErr bool
	}{
		{
			"invalid inputs, must return error",
			args{zero, 0},
			0,
			true,
		},
		{
			"valid inputs, must return a valid ciphertext",
			args{ct2, 2},
			1,
			false,
		},
		{
			"valid inputs, must return a valid ciphertext",
			args{ct36, 2},
			18,
			false,
		},
		{
			"valid inputs, must return a valid ciphertext",
			args{ct36, 6},
			6,
			false,
		},
		{
			"valid inputs, must return a valid ciphertext",
			args{ct36, 5},
			7,
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := pk.DivPlaintext(tt.args.ct, tt.args.pt)
			if (err != nil) != tt.wantErr {
				t.Errorf("PublicKey.DivPlaintext() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if err != nil {
				return
			}

			// Test the homomorphic property
			sum, err := sk.Decrypt(got)
			if err != nil {
				t.Errorf("PublicKey.DivPlaintext() error = invalid ciphertext generated by addition")
				return
			}
			if sum != tt.want {
				t.Errorf("PublicKey.MultPlaintext() = %v, want %v", sum, tt.want)
			}
		})
	}
}
